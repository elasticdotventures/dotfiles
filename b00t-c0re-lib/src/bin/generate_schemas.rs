//! Schema generator for b00t unified configuration
//!
//! This binary generates TypeScript types and JSON schemas for the dashboard UI.
//! Run with: `cargo run --bin generate_schemas`

use anyhow::Result;
use b00t_c0re_lib::b00t_config::*;
use schemars::schema_for;
use std::fs;
use std::path::Path;
use ts_rs::TS;

fn main() -> Result<()> {
    println!("ðŸ—ï¸  Generating TypeScript types and JSON schemas for b00t unified configuration...");
    
    // Create output directories
    let ts_types_dir = "/home/brianh/promptexecution/infrastructure/b00t/dashboard/src/types";
    let json_schemas_dir = "/home/brianh/promptexecution/infrastructure/b00t/dashboard/src/schemas";
    
    create_dir_if_not_exists(ts_types_dir)?;
    create_dir_if_not_exists(json_schemas_dir)?;
    
    // Generate TypeScript types using ts-rs
    println!("ðŸ“ Exporting TypeScript types...");
    export_typescript_types()?;
    
    // Generate JSON schemas using schemars
    println!("ðŸ“‹ Generating JSON schemas...");
    generate_json_schemas(json_schemas_dir)?;
    
    // Generate a comprehensive index file
    println!("ðŸ“¦ Creating index exports...");
    create_typescript_index(ts_types_dir)?;
    create_schema_index(json_schemas_dir)?;
    
    println!("âœ… Schema generation completed successfully!");
    println!("   TypeScript types: {}", ts_types_dir);
    println!("   JSON schemas: {}", json_schemas_dir);
    
    Ok(())
}

fn create_dir_if_not_exists(path: &str) -> Result<()> {
    if !Path::new(path).exists() {
        fs::create_dir_all(path)?;
        println!("ðŸ“ Created directory: {}", path);
    }
    Ok(())
}

fn export_typescript_types() -> Result<()> {
    // Export all TypeScript types
    B00tUnifiedConfig::export()?;
    UserConfig::export()?;
    CloudServicesConfig::export()?;
    CloudflareConfig::export()?;
    AwsConfig::export()?;
    QdrantConfig::export()?;
    CloudServiceConfig::export()?;
    AiConfiguration::export()?;
    AiProviderConfig::export()?;
    AiPreferences::export()?;
    DevelopmentConfig::export()?;
    EnvironmentPreferences::export()?;
    GitConfig::export()?;
    DeploymentConfig::export()?;
    SecurityConfig::export()?;
    ConfigMetadata::export()?;
    
    // Export enums
    CloudflareService::export()?;
    AwsService::export()?;
    AuthMethod::export()?;
    KeyringBackend::export()?;
    
    // Export nested configs
    S3BucketConfig::export()?;
    QdrantCollectionConfig::export()?;
    TerminalConfig::export()?;
    DeploymentTarget::export()?;
    CicdPreferences::export()?;
    
    Ok(())
}

fn generate_json_schemas(schemas_dir: &str) -> Result<()> {
    // Generate JSON schemas for form validation
    let configs = vec![
        ("B00tUnifiedConfig", schema_for!(B00tUnifiedConfig)),
        ("UserConfig", schema_for!(UserConfig)),
        ("CloudServicesConfig", schema_for!(CloudServicesConfig)),
        ("CloudflareConfig", schema_for!(CloudflareConfig)),
        ("AwsConfig", schema_for!(AwsConfig)),
        ("QdrantConfig", schema_for!(QdrantConfig)),
        ("AiConfiguration", schema_for!(AiConfiguration)),
        ("AiProviderConfig", schema_for!(AiProviderConfig)),
        ("DevelopmentConfig", schema_for!(DevelopmentConfig)),
        ("SecurityConfig", schema_for!(SecurityConfig)),
    ];
    
    for (name, schema) in configs {
        let schema_json = serde_json::to_string_pretty(&schema)?;
        let file_path = format!("{}/{}.json", schemas_dir, name);
        fs::write(&file_path, schema_json)?;
        println!("   ðŸ“„ Generated schema: {}.json", name);
    }
    
    Ok(())
}

fn create_typescript_index(types_dir: &str) -> Result<()> {
    let index_content = r#"// Auto-generated TypeScript type exports for b00t unified configuration
// Generated by: cargo run --bin generate_schemas

export * from './B00tUnifiedConfig';
export * from './UserConfig';
export * from './CloudServicesConfig';
export * from './CloudflareConfig';
export * from './AwsConfig';
export * from './QdrantConfig';
export * from './CloudServiceConfig';
export * from './AiConfiguration';
export * from './AiProviderConfig';
export * from './AiPreferences';
export * from './DevelopmentConfig';
export * from './EnvironmentPreferences';
export * from './GitConfig';
export * from './DeploymentConfig';
export * from './SecurityConfig';
export * from './ConfigMetadata';

// Enums
export * from './CloudflareService';
export * from './AwsService';
export * from './AuthMethod';
export * from './KeyringBackend';

// Nested configs
export * from './S3BucketConfig';
export * from './QdrantCollectionConfig';
export * from './TerminalConfig';
export * from './DeploymentTarget';
export * from './CicdPreferences';

// Type guards and utilities
export function isB00tUnifiedConfig(obj: any): obj is B00tUnifiedConfig {
  return obj && typeof obj === 'object' && 'user' in obj && 'cloud' in obj && 'ai' in obj;
}

export function isValidUserConfig(obj: any): obj is UserConfig {
  return obj && typeof obj === 'object' && typeof obj.username === 'string';
}

// Re-export for convenience
export type { 
  B00tUnifiedConfig as UnifiedConfig,
  AiConfiguration as AiConfig,
  CloudServicesConfig as CloudConfig,
  DevelopmentConfig as DevConfig 
};
"#;
    
    let index_path = format!("{}/index.ts", types_dir);
    fs::write(index_path, index_content)?;
    println!("   ðŸ“¦ Created TypeScript index file");
    
    Ok(())
}

fn create_schema_index(schemas_dir: &str) -> Result<()> {
    let index_content = r#"{
  "title": "B00t Unified Configuration Schemas",
  "description": "JSON schemas for b00t configuration validation",
  "version": "1.0.0",
  "schemas": {
    "B00tUnifiedConfig": "./B00tUnifiedConfig.json",
    "UserConfig": "./UserConfig.json",
    "CloudServicesConfig": "./CloudServicesConfig.json",
    "CloudflareConfig": "./CloudflareConfig.json",
    "AwsConfig": "./AwsConfig.json",
    "QdrantConfig": "./QdrantConfig.json",
    "AiConfiguration": "./AiConfiguration.json",
    "AiProviderConfig": "./AiProviderConfig.json",
    "DevelopmentConfig": "./DevelopmentConfig.json",
    "SecurityConfig": "./SecurityConfig.json"
  }
}
"#;
    
    let index_path = format!("{}/index.json", schemas_dir);
    fs::write(index_path, index_content)?;
    println!("   ðŸ“¦ Created JSON schema index file");
    
    Ok(())
}