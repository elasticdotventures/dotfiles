
# \__b00t__
------
Status: merging my own various scripts from other projects, setting up the interactive initalization (using fzf).  Sharing with friends, looking for feedback, alpha testers & contributors. Comments, issues, PR's welcome. Please üç¥üç∞ü§©.  


------
```text/plain
      __         __      __   __                
     /\ \      /'__`\  /'__`\/\ \__             
     \ \ \____/\ \ \ \/\ \/\ \ \ ,_\            
      \ \ '__`\ \ \/\ \ \ \/\ \ \ \/            
       \ \ \L\ \ \ \/\ \ \ \_\ \ \ \_           
        \ \_,__/\ \____/\ \____/\ \__\          
  _______\/___/  \/___/  \/___/  \/__/  _______ 
 /\______\                             /\______\
 \/______/       ÂºÄÊú∫ü•æüêõËô´Â≠ê          \/______/ 
   B U G   S Q U 1 S H 1 N G   S O F T W A R 3
            FOR APPLICATION DEVELOPERS

# ü§ì QUICKSTART:
git clone https://github.com/elasticdotventures/_b00t_.git
bash$ source ./_b00t_/_b00t_.bashrc
# then maybe try the setup: 
bash$ cd _b00t_; ./01-startup.sh 
```

# ü•æ is presently suitable for: 
pre-dev stage projects 
self-reliant engineering teams (no vendor support, except the Author & Git Issues)

# _b00t_ Vs. Moby
_b00t_ is NOT Docker Moby, although it shares some common goals. 

Like Moby _b00t_ is ALSO perfect for:
* Hackers who want to customize or patch their Docker build (or want a better one)
* System engineers or integrators building a container system
* Application developers looking for an easy way to run their Python, Typescript and related applications in containers with VS Code, Azure Tooling & best practices.

_b00t_ is an early stage complete ops-stack for a company (examples included) to quickly easily and affordably, minimize and properly compartmentalized microservices by functional behavior characteristics (mostly in Azure).  Caching and other layers included to reduce costs and monitor integrity. 

# What _b00t_ intends to provide: 
```
    * Functional Examples & Opinionated Toolchoices & VS COde Dev Environment integration. 
    * FZF menuing and high automata, with detailed config notes. 
    * Repeatable "clean" environment with sane defaults, that can be easily disabled i.e. remove python or remote typescript, select database, deployment zones, etc. 
    ** For application developers. 
```

# Application Design: 
```
    * Best industry practices security built-in OAuth/OpenID, etc.
    * Hardened Determinsic Patterns using Azure Durable Functions
    * Colorful and easy to read cyberpunk Emoji & Pinyin filled logs & metrics, v3ry 3117! 
    * Multi-stage dev, build, test, deploy CI/CD - coming soon. 
    * Containerized Projects that deploy at cloud scale
    * Especially well suited for:
        * Machine Learning Create=>Cloud_Deploy Pipelines
        * Bi-lingual projects using Python & Typescript (or others)
        * StoryTime Forensic Analysis using eBPF (s0meday)
    * Demo/Modules Roadmap (using _b00t_):
        * v0: present. work in progress. 
        * v1: AiiA Call Center [http://github.com/elasticdotventures/aiia-callcenter] - Small Business NLP/TTS/STT "Call Center" intelligent assistant based on Jovo framework, with additional interfaces for discord & slack. bigCommerce integration planned. 
        * v2: DongXi Inventory [http://github.com/elasticdotventures/dongxi] Discrete Inventory & Accounting, Ethereum & Solidity Interfaces. bigCommerce integration.  
        * v3: gr0w.P0t.B0t [http://github.com/elasticdotventures/gr0w.P0t.B0t]  AI-driven Hydroponic Biogenesis Appliance (hydroponic farm controller) built on ESP32 with AI. 

   Currently under development:
      * internal libraries and essential tooling, docker deploy, then integrate AZ with bicep. 
      * fzf menus & installer
```

# \__b00t__

## What About \_b00t_?
ElasticDotVentures \_b00t_ is 
a highly opinionated set of tools for deploying Azure cloud services with EV libraries (called "c0re", a subset of "c0de"), mostly for Azure ü§ñ.  \_b00t_ brings together a series of powerful Cloud tools to challenge certain traditions proffered by the academic establishment to encourage a non-traditional but extremely p0werful mix-martial-art-of-code.   This text here is mostly visionary explaining the "what" about _b00t_ which is presently early stage being re_b00t_edüòÜ from my prior projects. 

## Is _b00t_ a better for individuals or teams?
Probably individuals is easier, certainly from an adoption standpoint. Not everybody can gr0k _b00t_.  If you can, great! _b00t_ means you don't need a team to do the stuff because _b00t_ does stuff for you.  Built by a serial-entrepeneur, _b00t_ is a great "stack" for Robotics & AI Startups where the product's very survival is often dependent on efficient (cost-saving) internal-tooling. 

_b00t_ is also great for teams the VS Code Live Share feature & Remote Containers, and Azure Hybrid-Connections offers a plurality of one-click easy, low-latency for teams to share screens securely through firewalls.  It's built in a way so that you could give people their own instance of your code, even limit the amount of funding per-new-customer trial. Something like google Collab for startups. The author believes this is especially useful if (for example) you desire to collaborate with other researchers, especially Chinese ones (i.e. hardware startups) thanks to it's incorporation of Emoji and Pinyin. 

## _b00t_ Syntax Rationale: 
Don't Panic! The future requires new approaches. 

The _b00t_ approach uses incorporates 1337 speak for c0mm0n words to encourage brevity at all layers. _b00t_'s design is built to tightly couple the Azure cloud, but integrate with others for services.  Creating multi-layer pipelines using a menu driven approach to generate templates and then execute those templates, download the projects, then build and rebuild, deploy continuously. 

The 1337speak used in _b00t_ is primarily used to make unique pnemonics that are substantially easier to grep during a subsystem trace across layers in the stack, thus providing f1ng3r printing.  The naming models create colorful and meaningful filters to radically improve code quality & debuggability and incorporating "zero-code" deterministic actions Azure Logic Functions. The
higher visual payload of short 1 & 4 character Emoji & HSK1 in names is informative, and has valuable screen real-estate. WIN+";" is emoji keyboard /(*in windows)/ - but Emoji with cut and paste + intellisense make this easier than you'd think.  Especially when you type "d0cker" and a üê≥ pops up in spell check using a custom dictionary. 

1337 mechanics generally indicate logical role or purpose. Using tab-complete in Intellisense IDE and CLI makes it easy and artistic on the screen reinforcing art-in-code.  _b00t_ focusing on the pictures and basic glyph optimized based Simplified Mandarin only reading the code when it's necessary.  This approach allows for grouping by symbol and simplifies some aspects of command line searching properties, test generation and several other aspects.  

Built to deploy Azure Logic Connectors & Azure Durable Functions with Python & Typescript Connectors, Azure Service Bus üöå, Azure KeyVaultüíé Configs‚öôÔ∏è, Azure ARM/Bicep üí™. Check Jargon.md for more the full glossary & naming conventions.  

Docker üê≥, Python üêç, TypeScript ü¶Ñ - emoji indicates things like designee, consignee, etc.  This is an important aspect of the "storytell" logging.  StoryTell creates really colorful transaction logs & error dumps, these will eventually be extended to perform basic ML application forensics & monitoring using eBPF in the Linux Kernel.  These meta-patterns (using computers to monitor computers) helps our soon-to-be-obsolete primate brains abstract patterns that wouldn't be nearly as obvious in regular English text and notice problems and inform the determinisitic control surfaces to take action (isolate, block-hold, ignore with possible consequences üò¨).  This isn't the whole application freezing, it's a message in an application, or a corrupt video frame grabber in a video stream, any payload which doesn't match the model.   It's not lost forever, it's simply flagged for review. 

# Example (in code)
_b00t_ is bi-lingual, one of the c0des it understands is bash script. 
Here's a sample Bash function taken from the c0re to see if a machine is running Windows System for Linux version 2, abbreviated to WSLv2. The Emoji colorfully demonstrates this bi-lingual principle: 
```bash

## Microsoft Windows Linux Subsystem II 
## ü§ì https://docs.microsoft.com/en-us/windows/wsl/install-win10
#
function is_WSLv2_üêßüíôü™üv2() {
    return `cat /proc/version | grep -c "microsoft-standard-WSL2"`
}

```

## And here's how to decode it:
* üêß Penguin .....  Linux (Tux, Mascot)
* üíô Blue Heart ..  Microsoft:üíô, Google:üíö, AWS:ü™ô
* ü™ü Windows .....  self explanatory! (*may not appear on Android!)

So: Without knowing what WSLv2 "is" using only three symbols you can infer a lot about it! 

This behavior becomes a mighty _SUPERPOWER_ü¶∏ when used with the new [eBPF](https://ebpf.io/) Linux kernel features, discussed elsewhere. 


# ‚ö†Ô∏è Disclaimer
This is Alpha software. _b00t_ is Provided AS-IS! \_b00t_is rique NFSW, for example a default project could be auto-named "butt_plug" or something like that, it's intentionally cheeky and non-discriminatory.  _b00t_ contains a powerful build process that can muster substantial resources.  

# ü•ã Mixed-Martial-Art-Of-Coding: "StoryTime Logging"
\_b00t_ is designed around the idea of "StoryTime" logging that includes Emoji & HSK 1 Chinese Vocabulary - Please Don't be intimidated.  Default settings leave English translations on.  The Author (@BrianHorakh) is a native English speaker and multi-language polygot (Spanish, Mandarin, ~Italian, ~German, ~Portguese) all have their own linguistic style and strengths.  Think of this as mixed-martial-art-of-coding! 

# ü§Ø ‰∏∫ÊòØÂêóTF is HSK1? 
HSK1 is Level 1 Chinese Mandarin language skill, in this case using simplified pinyin symbols. Simplified Pinyin is a screen glyph optimized font - that means HSK1 characters are very easy to read!  Presently emoji pictograms are second-class languages are both regionally-ambiguous i.e. "üçÜüí¶" has a plurality of meanings but it is two easy to recognize symbols "eggplant water".  

Simplified Pinyin is a very pretty font, it's designed to be more legible than traditional chinese on electronic devices. Simplified Pinyin is useful in a LOT of places (such as Azure Resource Names) where Emoji is not presently allowed. 

 Chinese pictograms are essentially the "original" black & white Emoji. HSK1 contains roughly ~500 word-meanings in a single character position (screen real-estate).  When we talk about Good naming conventions -- i.e. logic-role, _b00t_ tries to use uniform fixed width sequences 1-4 characters to hint, so Emoji + Mandarin-Pinyin. 

If _b00t_ was restricted to ONLY the western English 36 characters (A-Z,0-9) that would results in ~1.6m possible combinations & meanings and probably a dozen abbreviated words at most, not descriptive at all!   Those same 4 character positions using 1024 Emojis (~1.9tn), plus 500 HSK1 mandarin characters (~62.5bn), in total 1560 characters (36+1024+500) results in 5.9 TRILLION possible "stories" encoded in only 4 characters that your brain needs to process! 

Wow, so 4 characters of _b00t_ can represent *5.9 TRILLION stories*! ü§Ø With *DEFAULT* English mode, the system will append the English. Keyboard translations in Windows & VS Code Extensions are coming, templates for cutting and pasting are herein. 

_b00t_ is quicker-than-you'd-think to learn (our brains like patterns) after a short while you'll learn the ÊÑè (Y√¨, English: "Meaning of") Chinese characters, till then just cut and paste from the samples, navigate with pictures, some vocabulary is included in files. ü™ÑüòÅ! now you're learning to read basic Pinyin!  Chinese Mandarin (Pinyin users) represent 1.8 billion humans, roughly 1/3rd of the population.  English also has roughly 1.8bn globally -- HOWEVER only 400m are native speakers, everybody else already speaks another language besides English first! Emoji is universal.   

# ü§© Wait, What does _b00t_ do? 
\_b00t_ is an *opinionated* pipeline orchestration system with integrated VS Code development environemnt, CI/CD Pipeline, base system which is suitable for deploying any cloud-scale state-less machine-learning project in frameworks such as Nvidia Cuda, PyTorch, Tensorflow, etc. as desired.  \_b00t_ provides the base idempotent templates for resources & public/private code-libraries written in Azure ARM/Bicep. 

The ultimate output is a fully operational cloud-resource group, sensibile file shares, key-vaults, monitoring, logging scaffold skeletons in TS & Python as well (the "c0re") which presents itself as an interactive filesytem/blob storage.  Python & Typescript bindings. I'll eventually add some higher level Vue templates and hardware IOT/Arduino & ESP32 templates as well. When they run, they create beatiful stories in your logs about transactions. 

One aspect \_b00t_ is that it can be hardened and subsequently removed (using docker dive) during the publish to live/production.

From the \_b00t_ perspective it's going to help you build SOMETHING, it's only a foundation.  Further application templates can be built on _b00t_ and then easily upgraded taking advantage of new features. 

In Cloud based determinsic systems (such as Azure Logic Functions), containers can be "frozen" fully loaded, or kept hot (with standbys) based on a load balancer. Such as a cloud-function (or container) can be readonly NVM-e backed memory "blob" that is awaiting a trigger (probably by an inbound HTTP Websocket, E_POLL, or io_submit() ). 
The published container can be stripped down thus improving both size & security posture by removing tools & configuration files from public facing images. 

Cloud based AppConfig Stores & KeyVaults are used. KeyVaults contain types that are first-order types which are aware the passwords, etc. in them must be kept secure.  For example in Azure Logic Functions secure tokens (such as passwords, or access keys) from a Vault are tagged and automatically beautifully-filtered from logs as well! This makes compliance & user privacy easier! Extensive use of pipelines and messaging queues allow for tests and other large jobs to be run in parallel at cloud scale.  

# What _exactly_ is Cloud Scale?
Cloud Scale, with respect to \_b00t_ refers to highly parallelized jobs which can be executed simulatenously.  For example if you have 1,500 tests and each one takes avg 2 seconds to run, that's roughly 50 minutes to "finish" tests before you can even start a build to production.  A cloud scale approach would be to complete those tests in parallel on 1,500 servers thus only takes 2 seconds (or, actually as long as the longest test, which is often a timeout, so ~60 seconds) .. but the same pattern also works for deploying containerized neural-network layers using more optimized protocols such as Google ProtocolBuffers. 




# Why does Opionated mean? 
For example, _b00t_ believes that VS Code with it's intellisense, typescript & python, docker, azure, aws, gcp, and plurality of other useful extensions makes VS Code the one true editor.  The author believes _b00t_ pattern works best when using remote containers, which is one of the Â±Ç Layers it builds & configures. 

The \_b00t_ organizational pattern is formatted around an intentionally lean "svelte" Enterprise, everything is automated and structured for easy updates using Git. Debugging is on by default but can be reduced later to save $$. Serverless/consumption plans are also default and cost centers are isolated by project/resource group for good reporting & security.  _b00t_ assumes an agile cadence of releasing early and continuously integration. _b00t_ assumes VS Code as an integrated environment, thus prescribing a suggest list of IDE extensions. An emphasis is put on Windows development with plans to integrate a custom language pack based on a US keyboard (thus similar to intellisense hinting, but at the OS layer)

Ultimately it will include internal tooling sufficient to run a company through built on top of the _b00t_ template.  Plans to compile a variety of unique reporting summarized using _b00t_ notation to quickly assess project quality, code sentiment analysis and identify weak spots.

Additional plans include using the eBPF Linux Kernel filter for fast (kernel level) debugging and monitoring (learning patterns of good and bad transactions).  In this capacity Emoji & HSK is universally better suited than English which would require some level of cost-intensive NLP to be as-effective.  In this capacity _b00t_ saves money with a higher (better) payload to transmission size of packets. 

# What is Idempotence & Determinism? 
https://en.wikipedia.org/wiki/Idempotence
Idempotence (UK: /Àå…™d…õmÀàpo ät…ôns/,[1] US: /Àåa…™d…ôm-/)[2] is the property of certain operations in mathematics and computer science whereby they can be applied multiple times without changing the result beyond the initial application. 


A deterministic algorithm is an algorithm which, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states.   

Using Azure Functions, and Azure Logic Apps for orchestrating actions which allows a _b00t_ stack to behave as a globally distributed finite-state machine.   This is the higest level of durability which can be assigned to a software platform and is suitable to running fail-safe systems such as nuclear reactors. The author explicitly disclaims any responsibility for circumstances occurring decide to use _b00t_ to run your own backyard reactor.

https://en.wikipedia.org/wiki/Deterministic_system


# What is so Opionated? 
0MG. _b00t_ tries very hard to be Templates and Tools ("TnT") but inevitably through the selection of those it's opinions on "best" approach.  For example, snapd packages are at the core of ubuntu, and for various reasons ubuntu is the base image.   Even if you start at alpine Linux it's going to look very ubuntu-ish if you use _b00t_. 

The organizational pattern is formatted around a cross-competency, "Don't make me think" (any more than I need to) so it assigns emojis to meanings.  

This allows for the system to implement "story tell" during logs, showing entire transactions as a series of pictograms (colorful markov chains). Here is a sample of the _projects_ layout opinion: 

```
Here are the _projects_ opinion: 

/hoome/.b00t/    # your configs
|- ./your_Project/..   # each project has it's own directory. 

/c0de/
|- /_b00t_    # where your projects live
|- /project/  # your configs. 

# ü§ì NOTE:
#   improve security posture: make upper level filesystems
#   readonly and removing configs from lower levels using 
#   docker "dive"

# Files:

/c0de/*                # rationale: 4 characters.  
 |- ./01-start.sh      # üç∞ ** Start Here!! Run this ./01-start.sh **
 
/c0de/_b00t_           # contains the repo. PUT this repo here.  
 |- ./bash/            # anything in a .sh, templates
 |- ./bash/c0de_init.üöÄ.sh   # also, the main init script, called from ./01-start.sh 
 |- ./Dockerfile       # base Docker image (standard)
 |- ./docker.üê≥/      # additional Docker build files, emoji coded Â±Ç (C√©ng) Layers
 |- ./python.üêç/      # python stuff that will probably end up in _t00ls_
 |- ./node-ts.ü¶Ñ/     # typescript libraries
 
/c0de/cloud.üå©Ô∏è
 |- ./azure.ü§ñ/       # azure cloud 
 |- ./google.üëæ/      # google cloud (still fresh) 
 |- ./aws.ü¶â/         # aws cloud (nothing planned here, presently) 
 |- ./aws.ü¶â/         # aws cloud (nothing planned here, presently) 

```

By subscribing to this pattern, an effort is made to obviate certain things.  
Layers are built upon layers. 
For example a deployed system can be wiped of Dockerfiles using:

```
rm -Rf ./Dockerfile ./docker.üê≥
```

This is handy at later builds.  For example a GIT filesystem can be stripped of utilities that is no longer needed.  Once that is compressed at a Docker Buildx layer then that information has destroyed during the idempotent container creation. 

```
## Tools of _b00t_
* Git
* Bash
    * JQ - https://stedolan.github.io/jq/download/
    * YQ - 
    * FZF - 
* Python
* Node-Ts
* Docker
```

_b00t_ assumes the author will (ultimately) decide to end up using a combination of stateful logic so it simplifies the interface to those by creating a unified command language that can be further build on.  There is a method to the madness, I assure you.  The patterns utilize serverless consumption plans whenever possible.  The plan is to eventually include complete VS code project files & plugin.    This assumes the developer(s) are using a three stage release model, "InnerLoop" (Local), "OuterLoop" (Cloud and/or Local), "Production" (Live) each of those moving the data to the cloud and toward the public, no attempts are made. 

# Want to see examples Emoji & HSK1 Chinese
https://brianhorakh.medium.com/emoji-logging-warning-much-silliness-ahead-4cae73d7089


``txt
/c0de/_b00t_                     : this bootstrap code.
/c0de/_b00t_/01-start.sh         : setups up environment
/c0de/_b00t_/02-project.sh       : create a new project, with tooling. 
/c0de/_b00t_/ZZ-remove.sh        : clean up a project 
``


## Get Started: 
NOTE: Someday (soon-ish) I'll have this as a DEPLOY to AZURE button working!

```bash
For now:

export resourceGroup="newProject"
export region="useast"

mkdir -p /c0de && cd /c0de
git clone git@github.com:elasticdotventures/_b00t_.git
cd ./_b00t_/ && ./01-start.sh

that will start running the soon-to-be interactive installer. 
```

Then, once you've setup _b00t_ you can start to create your own projects. 

```
# to start a new project: 
/c0de/_b00t_/up new ~ 

# or: 
my_project_id="<YOUR PROJECT>"
/c0de/_b00t_/up new $my_project_id 

```

\_b00t_ will create your project in /c0de/$my_project_id
In the future to upgrade \_b00t_ you can simply use GIT. 
```

```
# Or clone AiiA! 
AiiA is the tool being built in _b00t_, it's an NLP call center application. 
(http://elasticdotventures/aiia-callcenter)


#  When Finished:
you'll have a fully integrated development environment with secure language bindings to two languages, full permission provision, resources with budget-friendly serverless consumption models by default. 

# To cleanup:
**NOT FINISHED**
```
/c0de/_b00t_/ZZ-cleanup.sh $my_project_id
```

# Emojis & Chinese on the CLI
The author is a hardcore CLI guy too.  For some things using your mouse to copy-paste is better since it eliminates fat fingers. Let's keep it real - nobody except absolutely masochists would try to hand-type AZ Resource strings, so \_b00t_ strings are no different.  You will need to do some cutting and pasting, you probably won't like \_b00t_ if you're developing on a Digital VT100 .. üôÑ yeah, nah. 

## How to move around \_b00t_ on the CLI
You use the CLI? You're 1337! 0k4y. Hack your brain to use tab complete & wildcard shortcuts. 

For directories with emojis or mixed case, use wildcards to hit targets. 
So `cd /c0*/` will chdir to `/c0de/`

Generally the targets use Emoji & HSK at the end, but as an exercise, here's a badly named directory: 
`/c0de/_b00t_/.../ËìùËâ≤_Bicep_ARM_AzrResMgr.üí™`

could be accessed from it's pwd using ANY of the following `cd` command. 
```
cd *Bicep*
cd *ARM*
cd *AzRes*
cd *üí™
```
Technically this file is misnamed, should be ```Bicep_ARM_AzrResMgr.üíôü§ñüí™```

On Windows, make sure you're using WSL2 on Unbuntu 20.04 with Windows Terminal Preview rather than the default shell and emoji works fine.  Putty and VS Terminal both work for outbound SSH and Sakura for inbound X-term/RDP.  If you're terminal doesn't support emoji, switch terminals.   If you're still using Vim you're missing intellisense in VS-Code and literally every single task is more difficult and error prone.  Tools like Azure ARM Bicep *assume* VS Code + intellisense for their transpiler also, so no VIM/Emacs support there. 

# StoryTelling in Emoji & HSK1 Chinese
I'm not gonna here, just read my Medium:
https://brianhorakh.medium.com/emoji-logging-warning-much-silliness-ahead-4cae73d7089


Future:
https://unikraft.org/

